{
  "name": "browser-stream-server",
  "version": "0.3.1",
  "description": "A stream server in the browser",
  "keywords": [],
  "author": {
    "name": "Raynos",
    "email": "raynos2@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/Colingo/browser-stream-server.git"
  },
  "main": "index",
  "homepage": "https://github.com/Colingo/browser-stream-server",
  "browserify": "browser.js",
  "contributors": [
    {
      "name": "Jake Verbaten"
    }
  ],
  "bugs": {
    "url": "https://github.com/Colingo/browser-stream-server/issues",
    "email": "raynos2@gmail.com"
  },
  "dependencies": {
    "hat": "0.0.3",
    "node-uuid": "~1.3.3",
    "stream-store": "~0.2.0",
    "stream-router": "0.0.2",
    "pause-stream": "0.0.3",
    "through": "~0.1.4",
    "duplexer": "0.0.1",
    "ap": "~0.1.0",
    "xtend": "~1.0.3"
  },
  "devDependencies": {
    "boot": "~0.6.1",
    "browserify-server": "~0.2.0",
    "lazynode": "~0.1.0"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/Colingo/browser-stream-server/raw/master/LICENSE"
    }
  ],
  "scripts": {},
  "readme": "# browser-stream-server\n\nA stream server in the browser\n\nCreate streaming servers in your browser. Emulating peer to peer connections through a central proxy server\n\n## Example browser server (In a seperate browser)\n\n``` js\nvar StreamServer = require(\"browser-stream-server\")\n    , boot = require(\"boot\")\n    , mdm = boot(\"/boot\")\n\n// Open a Stream server and listen on a server name\nStreamServer(mdm, function (stream) {\n    // Called every time a client opens up a stream connection to you\n    stream.on(\"data\", function (data) {\n        console.log(\"[SERVER]\", data)\n    })\n    stream.write(\"from server\")\n}).listen(\"SERVER_NAME\")\n```\n\n## Example browser client (In a seperate browser)\n\n``` js\nvar StreamClient = require(\"browser-stream-server\")\n    , boot = require(\"boot\")\n    , mdm = boot(\"/boot\")\n\n// Open a connection to a named stream server\nvar stream = StreamClient(mdm).connect(\"SERVER_NAME\")\nstream.on(\"data\", function (data) {\n    console.log(\"[CLIENT]\", data)\n})\nstream.write(\"from client\")\n```\n\n## Example proxy server\n\n``` js\nvar boot = require(\"boot\")\n    , StreamServerProxy = require(\"browser-stream-server\")\n    , StreamRouter = require(\"stream-router\")\n\n// route stream traffic from boot through a stream router\nvar streamRouter = StreamRouter()\n    , sock = boot(streamRouter)\n\n// for every request to /browser-server let the StreamServer proxy handle it\nstreamRouter.addRoute(\"/browser-server/*\"\n    , StreamServerProxy(\"/browser-server\"))\n\nsock.install(someHttpServer, \"/boot\")\n```\n\n## Motivation\n\nThis a pre-runner to real P2P experiments that will be done once we can create [data channels][3] with WebRTC\n\nThis is the smallest piece necessary to spawn arbitary stream servers in browsers.\n\n## Documentation\n\n### `StreamClient(mdm, options).connect(serverName)`\n\nTo be used in the browser\n\n``` js\nvar StreamClient = require(\"browser-stream-server\")\nvar stream = StreamClient(mdm).connect(\"SERVER_NAME\")\n```\n\nReturns a stream connection to that server name. It assumes the server is running somewhere else. If it's not then the stream is closed.\n\nThe `mdm` value is a [MuxDemux][4] stream. This can be got from mux-demux, mux-demux-shoe or boot.\n\noptions include a prefix option which allows you to set a custom prefix if the StreamServerProxy uses a custom prefix.\n\n### `StreamServer(mdm, options, callback).listen(serverName)`\n\nTo be used in the browser\n\n``` js\nvar StreamServer = require(\"browser-stream-server\")\nvar server = StreamServer(mdm, options, function (stream) {\n    // handle stream\n}).listen(\"SERVER_NAME\")\n```\n\nCreates a server stream connection. It assumes that named server is not already running somewhere else. If it is then the stream is closed.\n\nThe `mdm` value is a [MuxDemux][4] stream. This can be got from mux-demux, mux-demux-shoe or boot.\n\noptions are optional, you can pass a callback as the second parameter. The callback get's called every time someone else calls `.connect(serverName)` and you get passed a stream connection to them\n\noptions include a prefix option which allows you to set a custom prefix if the StreamServerProxy uses a custom prefix.\n\nTo close the server just `.end()` the returned server\n\n### `StreamServerProxy(prefix)`\n\nTo be used in the server\n\n``` js\nvar StreamServerProxy = require(\"browser-stream-server\")\n    , proxy = StreamServerProxy(\"/somePrefix\")\n// for every request to /browser-server let the StreamServer proxy handle it\nstreamRouter.addRoute(\"/somePrefix/*\", proxy)\n```\n\nSet up a steam route handler to allow the stream servers and clients to be proxied through your central server.\n\nOptionally pass in a prefix which defaults to `\"/browser-server\"`. If you pass in a different prefix make sure that your browser code matches the prefix.\n\n#### proxy events\n\nThe returned proxy object emits `server-created` and `server-destroyed` events when a server stream connects and claims to own the SERVER_NAME\n\n``` js\nproxy.on(\"server-created\", function (serverName) {\n    createSomeSpecialResources(serverName)\n})\n\nproxy.on(\"server-destroyed\", function (serverName) {\n    destroySpecialResources(serverName)\n})\n```\n\n#### `proxy.connect(\"serverName\")`\n\n``` js\nvar stream = proxy.connect(serverName)\n```\n\nYou can manually connect directly to a stream server. This runs similar logic to `StreamClient(...).connect(serverName)`\n\n## How it works\n\nWhen you call `StreamServer(...).listen(SERVER_NAME)` you open a server stream to the `StreamServerProxy` and tell the server \"redirect all connect SERVER_NAME traffic to me\"\n\nWhen you call `StreamClient(...).connect(SERVER_NAME)` you open a client stream to the `StreamServerProxy` saying \"connect me to SERVER_NAME\". The `StreamProxyServer` then sends a message to `StreamServer` identified by SERVER_NAME. The message contains a unique identifier, UNIQUE_ID for this client stream. The proxy server stores this client stream in memory.\n\nThe `StreamServer` receives this message and opens another connection to the `StreamServerProxy` saying \"hi I'm server SERVER_NAME and want to connect to client UNIQUE_ID\". The `StreamServerProxy` then gets the client stream out of memory and connects it to the new server connection which allows the client to talk to the server\n\n## Installation\n\n`npm install browser-stream-server`\n\n## Contributors\n\n - Raynos\n\n## MIT Licenced\n\n  [1]: https://secure.travis-ci.org/Raynos/browser-stream-server.png\n  [2]: http://travis-ci.org/Raynos/browser-stream-server\n  [3]: http://dev.w3.org/2011/webrtc/editor/webrtc.html#widl-RTCPeerConnection-createDataChannel-DataChannel-DOMString-label-DataChannelInit-dataChannelDict\n  [4]: https://github.com/dominictarr/mux-demux#muxdemuxoptions",
  "_id": "browser-stream-server@0.3.1",
  "_from": "browser-stream-server@~0.3.1"
}
